# 클린 아키텍처 - 구현
클린 아키텍처 패턴으로 간단하게 유저를 생성하는 웹 애플리케이션 로직을 파이썬으로 구현해봅시다.

## 엔티티

먼저 다음처럼 엔티티를 정의합니다. 엔티티는 도메인에 핵심을 표현하는 객체입니다.

```python
# domain/entities.py

@dataclass
class User:
    id: str
    name: str
    password: str
```



## 유즈 케이스

유즈 케이스는 엔티티를 가지고 애플리케이션에 다양하게 활용하는 유저 시나리오 입니다. 우리는 "유저 생성하기" 시나리오를 작성하고 있습니다.

```python
# application/use_cases/create_user.py

@dataclass
class CreateUserInputDto:
    user_name: str
    user_password: str

        
@dataclass
class CreateUserOutputDto:
    user_id: str
        
        
class CreateUser:
    def __init__(self, user_repository: UserRepository) -> None:
   	    # 의존성 역전을 위해 같은 레이어(applicaiton)에 있는 추상화된 UserRepository에 의존합니다.
        # 다시 말해, 인프라스트럭처에 정의될 구체적인 UserRepository 객체에 의존하지 않습니다.
        # 실제 런타임에서는 UserRepository를 상속받은 세부 클래스를 주입해야 합니다.
        # 세부 클래스는 인프라스트럭처 레이어에 정의되며, 이는 의존성 주입하는 부분에서 주입됩니다.
        self._user_repository = user_repository
    
    def execute(input_dto: CreateUserInputDto) -> CreateUserOutputDto:
        user_id = self._user_repository.get_next_user_id()
        user = User(id=user_id, name=input_dto.user_name, paassword=input_dto.user_password)
        self._user_repository.save(user)
        return CreateUserOutputDto(user_id=user_id)
```

```python
# application/interfaces/user_repository.py

class UserRepository(ABC):
    @abstractmethod
    def save(user: User) -> None:
        pass
```

> ***DTO(Data Transfer Object)란?**
>
> DTO는 말 그대로 데이터를 주고 받기 위해 사용하는 객체입니다. DTO에는 무언가 액션을 하는 메서드를 두지 않습니다. DTO는 그저 데이터를 담기만 해야합니다.  
> 보통 레이어간 의존성을 끊고, 도메인 모델을 보호하기 위해서 유즈 케이스의 입출력으로 DTO를 사용합니다. 예를 들어 위처럼 `CreateUser` 의 입출력으로 DTO를 사용하면, 이 유즈케이스를 사용하는 인터페이스 어댑터에서 도메인 모델 `User` 에 대한 의존성이 사라지게 됩니다. 만약 DTO로 전달하지 않고, `User` 를 그대로 인터페이스 어댑터에 전달하면, 인터페이스 어댑터에서 도메인 모델을 조작할 여지가 있고, 도메인 모델을 그대로 외부에 노출하는 셈입니다. 따라서 레이어간 DTO로 데이터를 주고받으며 의존성과 도메인 모델 노출을 없앨 수 있습니다.

## 인터페이스 어댑터

인터페이스 어댑터는 외부 영역과 내부 영역의 인터페이스를 변환해주는 역할을 합니다. 예를 들어 JSON 데이터를 유즈 케이스 입력으로 변환하여 유즈케이스를 실행한다거나, 유즈 케이스 출력을 JSON 데이터로 내보냅니다. 일반적으로 웹 애플리케이션에서 컨트롤러 객체가 바로 이 인터페이스 어댑터에 해당됩니다.

```python
# interface_adapter/controller/create_user.py

class CreateUserJSONRequest(BaseModel):
    name: str
    password: str

class CreateUserJSONResponse(BaseModel):
    user_id: str

def create_user(json_request: CreateUserJSONRequest) -> CreateUserJSONResponse:
    use_case = conatiner.get_usecase("create_user")
    input_dto = CreateUserInputDto(user_name=json_request.name, user_password=json_request.password)
    output_dto = use_case.execute(input_dto)
    return CreateUserJSONResponse(user_id=output_dto.user_id)
```





## 프레임워크 & 드라이버 (인프라스트럭쳐)

프레임워크 & 드라이버에는 웹서버나 DB 연동 객체 등 구체적으로 사용하는 세부 기술들이 놓이게 됩니다. 이 레이어는 인프라스트럭쳐 레이어라고도 합니다.  
여기서는 웹 인터페이스로 파이썬의 웹 프레임워크인 FastAPI를 사용하고, 리포지터리 객체의 DB와 연동은 SQLAlchemy ORM을 사용합니다.

```python
# framework_and_drvier/web.py

app = FastAPI()
router.add_api_route(
    path="/users", endpoint=create_user, methods=["POST"], status_code=201
)

if __name__ == "__main__":
    bootstar
    uvicorn.run(app)
```

```python
# framework_and_drvier/db/user_repository.py

class SQLAlchemyUserRepository(UserRepository):
    def __init__(self, session_factory: Callable[..., AbstractContextManager[Session]]) -> None:
        self.session_factory = session_factory
        
    def save(user: User) -> None:
        user_orm = UserORM.from_user(user)
        with self.session_factory() as session:
            session.add(user_orm)
            session.commit()
```



## 프로젝트 구조

```
domain/
  entities.py
application/
  use_cases/
    create_user.py
  interfaces/
    user_repository.py
interface_addapter/
  controller/
    create_user.py
framework_and_drvier/
  web.py
  db/
    user_repository.py
    datbase.py
    orms/
      user_orm.py
```



## 의존성 다이어그램

![image-20210916214832496](./images/image-20210916214832496.png)

> ***주의할 점**
>
> 네이밍을 꼭 레이어 이름대로 할 필요는 없습니다. 좀 더 명확한 네이밍이나, 팀에서 협의가 된 네이밍 규칙이 있다면 그것을 쓰면 됩니다. 또한 반드시 이런 패턴으로 100% 들어맞게 하지 않아도 됩니다. 상황에 따라 레이어 개수나 레이어별 의미는 달라질 수 있습니다. 중요한 것은 레이어 의존성의 방향이 바깥쪽 레이어에서 안쪽 레이어로 흘러야 한다는 것입니다.

<br>

## 좋은 아키텍처에 대한 고민

레이어드 아키텍처부터, 포트 앤 어댑터 그리고 클린 아키텍처까지 살펴보았습니다. 이런 아키텍처 패턴이 너무 많은 코딩량을 요한다고 생각이 드셨나요? 당장 프로젝트에 도입하기에는 너무 과하다고 생각이 드셨나요?

사실 아키텍처에 정답은 없습니다. 아키텍처는 아키텍처 자체로 남는 것이 아니라, 실제로 개발자들이 쉽고 지속적인 개발을 위해 존재합니다. 아무리 깔끔해보이는 아키텍처라고 하더라도, 당장 팀에 도움이 되지 않으면 무용지물로 남을 것입니다.

"쉽고 지속적이며 생산성을 높이는 아키텍처"를 위해서라면 어떤 아키텍처든 다음을 고민해봐야 할 것입니다.

- 프로젝트, 아키텍처 구조만 보고도 애플리케이션을 쉽게 파악할 수 있는가?
- 추가 확장 및 수정사항에 용이한 구조를 가지고 있는가?
- 개발자가 어떤 모듈을 어디에 두어야할지에 대한 고민을 줄여주는가?
- 쉽게 테스트 가능한가?

이런 질문에 해답을 내놓을 수 있는 아키텍처라면, 분명 개발 생산성에도 도움을 줄 수 있는 좋은 아키텍처 일것입니다. 더 좋은 아키텍처에 대해 고민하고 연구하는 것은 이제 여러분들에게 남아있습니다!

