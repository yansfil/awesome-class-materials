# 병렬성과 동시성

우리는 컴퓨터를 사용할 때 여러 프로그램을 실행시켜둔 채 사용합니다. 예를 들면 당장 저만해도, 크롬 브라우저에서 유튜브 음악을 들으며 카카오톡을 켜두고 텍스트 에디터로 글을 쓰고있습니다. 이 모든 것들이 한번에 일어나고 있습니다.

이번 글에서는 컴퓨터가 어떻게 한번에 여러 프로세스들의 작업을 수행하는지에 대한 개념과 방식을 다룹니다.

 <br>

## 동시성

컴퓨터의 구성요소 중 하나인 CPU(Central Processing Unit)는 말 그대로 컴퓨터 중심부에서 컴퓨터 명령을 처리하는 역할을 합니다. 우리가 컴퓨터를 사용하며 내리는 명령들, 예를 들어 "크롬 브라우저를 실행해줘"를 바로 이 CPU가 처리하는 것이죠.

> ***CPU Bounded vs I/O Bounded Task**
>
> 컴퓨터가 수행하는 하나의 작업은 CPU와 I/O 작업로 이루어집니다. 이 때 컴퓨터 작업을 크게 2가지로 나눠볼 수 있습니다. 하나는 CPU Bounded Task 이고, 다른 하나는 I/O Bounded Task 입니다.
>
> CPU Bounded Task는 작업을 실행하는데 I/O보다는 CPU를 더 많이 쓰는 작업을 말합니다. 예를 들면 머신 러닝과 같이 연산이 복잡한 로직이 여기에 해당합니다. I/O 작업이 아예 없는 것은 아니지만, 대체로 CPU 사용량이 더 압도적입니다.
>
> I/O Bounded Task는 작업을 실행하는데 CPU보다는 I/O가 더 많은 작업을 말합니다. 예를 들면 크롤링 로직, DB와 연결하여 데이터를 주고받는 로직 등이 여기에 해당합니다. 사실 우리가 사용하는 대부분의 작업들은 I/O Bounded Task에 해당합니다.

컴퓨터가 발전하던 초기에는 컴퓨터 하나당 CPU가 하나였습니다. CPU가 하나이니 한 번에 처리할 수 있는 명령도 하나였습니다. 따라서 여러 개의 명령어, 여러 프로세스를 실행하려면 시간이 오래 걸렸습니다. 이 속도를 좀 더 개선하고자하는 필요성이 떠오르기 시작합니다.

이 속도를 개선하고자 기존 작업의 CPU 사용량을 보니, CPU 사용량이 매우 낮다는 것을 발견했습니다. 예를 들어 어떤 작업이 1분이 걸린다고 하면, 그 중 10초만 CPU를 사용하고 나머지 50초는 I/O를 하는데에 사용하는 것이었습니다. 이 50초 동안 CPU는 아무것도 하지 않고 기다리게 됩니다. (이를 CPU가 블락 상태에 있다고 합니다.)

만약 이 50초 동안 가만히 있는 CPU를 그 다음에 수행되어야 할 작업이 바로 사용하게끔 만들어준다면, 전체적으로 작업 속도가 더 빨라질 거 같습니다. 즉 CPU가 가만히 있지 않도록 최대한 활용하도록 하는 것입니다.

이러한 아이디어는 운영체제에서 구현되어, 이제 하나의 CPU를 최대한 활용하여 여러 작업들을 빠르게 수행합니다. 여전히 CPU는 한번에 하나의 명령어만 처리하지만, CPU가 Block 상태가 되면 빠르게 다음에 처리해야할 프로세스가 CPU를 점유하여 사용하게 됩니다. (CPU 입장에서는 매번 여러 프로세스를 번갈아 가며 자신의 메모리에 불러오는 셈인데, 이렇게 CPU가 작업해야할 프로세스를 바꾸는 일을 "컨텍스트 스위칭"이라고 합니다.)

CPU를 점유하는 프로세스를 빠르게 바뀌고, 명령들도 빠르게 처리되다 보니 컴퓨터 사용자는 사실상 모든 프로세스의 명령이 "동시에" 처리된다고 느끼게 됩니다. 사실은 여전히 CPU는 1개에, 여러 프로세스를 컨텍스트 스위칭하며 한 번에 하나의 명령을 처리하고 있음에도 말이죠. 이렇게 진행되는 현상을 우리는 "동시성(Concurrency)"이라고 부릅니다.

![img](http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-1.png)

(출처: http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html)

<br>

## 병렬성

컴퓨터 하드웨어는 점점 발전하여, 이제 컴퓨터 하나당 2개 이상의 CPU를 가질 수 있게 되었습니다. CPU가 2개이므로 이제 우리는 동시에 2개의 명령어를 실행할 수 있습니다. 이렇게 여러 개의 작업을 동시에 진행되는 현상을 "병렬성(Parallelism)"이라고 부릅니다.

위에서 "동시성"은 실제로는 하나의 명령을 빠르게 수행하지만 처리속도가 매우 빨라 여러 작업이 동시에 진행되는 것처럼 "느껴지게" 해주었다면, 병렬성은 "실제로" 여러 개의 명령어를 동시에 실행하는 것입니다. 물론 운영체제가 여러 CPU를 골고루 쓰도록 매니징해줍니다.

![img](http://tutorials.jenkov.com/images/java-concurrency/concurrency-vs-parallelism-2.png)

(출처: http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html)

병렬성은 CPU를 2개 이상 사용하므로, 일반적으로 동시성보다 성능이 좋습니다.
또한 병렬성은 동시성을 품을 수도 있습니다. 여러 개의 CPU를 사용하면서 각각의 CPU에서는 동시성을 구현하는 것이죠.

<br>

## 멀티 쓰레딩

보통 우리가 작성하는 코드를 실행하면 하나의 프로세스로 동작합니다. 또, 하나의 프로세스는 보통 하나의 쓰레드만 사용하여 동작합니다. 예를 들면 파이썬 코드로 이를 확인해볼 수 있습니다.

```python
import os
import threading


def run() -> None:
    print(f"process_id: {os.getpid()}")
    print(f"thread_id: {threading.get_ident()}")

if __name__ == "__main__":
	run()
```

위 코드를 실행하면 다음과 같은 결과가 나옵니다.

```bash
process_id: 25939
thread_id: 4539137536
```

이렇게 하나의 프로세스에서 하나의 쓰레드만 사용하는 것을 "싱글 쓰레딩"이라고 합니다.
우리가 작성하는 대부분의 코드들은 이렇게 싱글 쓰레딩입니다.

그런데 하나의 프로세스에서 여러 개의 쓰레드를 사용할 수도 있습니다. 예를 들면 파이썬에서는 다음처럼 가능합니다.

```python
import os
import threading
from concurrent.futures import ThreadPoolExecutor


def run() -> None:
    print(f"process_id: {os.getpid()}")
    time.sleep(5)  # 5초 동안 대기합니다.
    print(f"thread_id: {threading.get_ident()}")


# run 함수를 실행하는 2개의 쓰레드를 띄웁니다.
if __name__ == "__main__":
    with ThreadPoolExecutor() as executor:
        n_threads = 2
        for _ in range(n_threads):
            executor.submit(run)
```

위 코드를 실행한 결과는 다음과 같습니다.

```python
process_id: 27180
process_id: 27180  # 같은 프로세스에서 생성했으므로, 프로세스 ID는 같습니다.

# (5초 뒤)

thread_id: 123145394302976
thread_id: 123145411092480  # 서로 다른 쓰레드이므로 쓰레드 ID는 다릅니다.
```

이렇게 여러 개의 쓰레드를 사용하는 것을 "멀티 쓰레딩"이라고 합니다.

![img](https://blog.kakaocdn.net/dn/CJq8c/btqzPm2y6GE/pXVqKklMl5iz7jk17UEECk/img.png)

(출처: https://granora2019.tistory.com/entry/TIL-004-multi-threading)

멀티 쓰레딩은 우리가 위에서 배운 "동시성"과 "병렬성"을 구현하는 방법 중 하나입니다. 컴퓨터가 하나의 CPU 코어만 가진 경우 "동시성"이 되고, 여러 개의 코어를 가진 경우 "동시성"과 "병렬성"이 둘 다 구현하는 셈이 됩니다. (여러 개의 CPU코어를 사용하면서 동시에, 각 코어에서 여러 개의 쓰레드를 컨텍스트 스위칭하며 사용하기도 하기 때문이죠)

그렇다면 멀티 쓰레딩은 보통 언제 사용하면 좋을까요?
멀티 쓰레딩을 사용하는 대표적인 경우는 독립적인 I/O Bounded 작업이 많은 경우입니다.

예를 들면 여러 사이트를 크롤링해야 하는 경우, 각 크롤링 작업은 대부분 I/O (해당 서버에 요청하고 응답받기 때문) 작업이기 때문에, 멀티 쓰레딩을 사용하기 좋습니다. 파이썬 코드로 대략적인 코드를 구현하면 다음과 같습니다.

```python
import requests


def parse(html_string: str) -> None:
    # html 문자를 파싱하는 로직이 들어갑니다.
    pass

def crawl(url: str) -> None:
    # 대부분 I/O Bounded 작업입니다.
    res.requests.get(url)
    parse(res.data())


urls = [
    "https://tansfil.tistory.com/",
    "http://dailyheumsi.tistory.com/",
    "https://zzsza.github.io/",
    "https://www.humphreyahn.dev/"
]

if __name__ == "__main__":
	# 최대 4개의 쓰레드를 띄워 각 쓰레드에서 위 주소들을 크롤링합니다.
	# 즉 크롤링(I/O Bounded) 작업이 동시적(concurrency)으로 일어납니다.
    with ThreadPoolExecutor(max_workers=4) as executor:
        for url in range(urls):
            executor.submit(run)
```

> ***파이썬의 멀티 쓰레드는 사실 싱글 쓰레드다.**
>
> 위에서 멀티 쓰레딩 코드를 구현했지만, 실제로 파이썬 내부적으로 싱글 쓰레드 위에서 동작합니다. 즉 실제로 멀티 쓰레드는 아니라는 것입니다. 파이썬 내부적으로 이렇게 실행되는 이유는 GIL이라는 개념때문인데, 파이썬 사용자라면 꼭 알아야할 개념입니다. 이에 대한 내용은 [이 글](https://dgkim5360.tistory.com/entry/understanding-the-global-interpreter-lock-of-cpython)을 참고하세요.

<br>

## 멀티 프로세싱

지금까지 하나의 프로세스만 사용해왔습니다. 이제 프로그램을 실행에 2개 이상의 프로세스를 사용해봅시다. 이를 멀티 프로세싱이라고 합니다.

예를 들면 파이썬 코드로 다음과 같이 구현할 수 있습니다.

```python
import os
import threading
import time
from concurrent.futures import ProcessPoolExecutor


def run():
    print(f"process_id: {os.getpid()}")
    time.sleep(5)
    print(f"thread_id: {threading.get_ident()}")


if __name__ == "__main__":
    with ProcessPoolExecutor() as executor:
        n_processes = 2
        for _ in range(n_processes):
            executor.submit(run)
```

위 코드를 실행하면 다음과 같은 결과가 나옵니다.

```python
process_id: 28394
process_id: 28393  # 서로 프로세스이므로, 프로세스 ID는 다릅니다.

# (5초 뒤)

thread_id: 4612054528
thread_id: 4766633472  # 서로 다른 프로세스 내에서 실행되고 있으므로 당연히 쓰레드 ID도 다릅니다.
```

멀티 프로세싱은 역시 "동시성"과 "병렬성"을 구현하는 방법 중 하나입니다. 컴퓨터가 하나의 CPU 코어만 가진 경우 "동시성"이 되고, 여러 개의 코어를 가진 경우 "동시성"과 "병렬성"이 둘 다 구현하는 셈이 됩니다.

그렇다면 언제 멀티프로세싱을 사용하면 좋을까요?
멀티 프로세싱을 사용하는 대표적인 경우는 독립적인 CPU Bounded 작업이 많은 경우입니다.

예를 들면 다음처럼 머신 러닝 코드에서 전처리하는 부분을 멀티 프로세싱으로 풀어낼 수 있습니다.

```python
import multiprocessing
from concurrent.futures import ProcessPoolExecutor

import numpy as np


def preprocess(data: np.array) -> np.array:
    # 대부분 CPU Bounded 작업입니다.
    ...

data = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
num_cores = multiprocessing.cpu_count() # 12

if __name__ == "__main__":
    # 데이터를 CPU 코어 수만큼 자릅니다.
    splited_data = np.array_split(data, num_cores)

    # 최대 CPU 코어 개수 만큼의 프로세스를 띄워 각 프로세스에서 데이터를 전처리하는 작업을 합니다.
	# 즉 전처리(CPU Bounded) 작업이 병렬적(parallelism)으로 일어납니다.
    with ProcessPoolExecutor(max_workers=num_cores) as executor:
        for data_chunk in splited_data:
        	future = executor.submit(preprocess, data_chunk)
            ...
```



> *** 멀티 쓰레드과 멀티 프로세스의 차이**
>
> ![Image for post](https://miro.medium.com/max/747/1*6Y7JWcTJUS4v4_CVHx8CCA.png)
>
> 멀티 쓰레드과 멀티 프로세스의 가장 큰 차이는, "메모리를 공유하는가?" 입니다.
> 멀티 쓰레드는 여러 개의 쓰레드가 하나의 프로세스 안에서 같은 메모리를 사용합니다.
> 멀티 프로세스는 각 프로세스가 별도의 메모리 공간을 갖습니다.
>
> 따라서, 멀티 쓰레드는 멀티 프로세스보다 적은 메모리 공간을 사용하며, 쓰레드간 컨텍스트 스위칭도 빠릅니다. 하지만 같은 메모리를 사용하므로, 각 쓰레드에서 메모리 사용에 주의해야 합니다. (보통 이러한 문제를 동기화 문제라고 합니다.) 또한 하나의 쓰레드가 장애 시 전체 프로세스에 영향을 줍니다.
>
> 멀티 프로세스는 멀티 쓰레드보다 더 많은 메모리 공간을 차지하고, 프로세스간 컨텍스트 스위칭도 쓰레드에 비하면 느린 편이지만, 각각의 독립적인 메모리 공간을 가집니다. 따라서 쓰레드에 비하면 시스템이 전체적으로 안정적입니다.
>
> 보통 메모리를 공유해야하고 간단하게 처리해야할 작업인 경우 멀티 쓰레딩을 사용하고, 독립적으로 별도의 메모리를 필요로 하는 무거운 작업인 경우 멀티 프로세싱을 사용하는 경우가 많습니다.

<br>

## 정리

- 동시성(Concurrency)은 하나의 CPU로 여러 작업을 빠르게 처리하는 것입니다.
    - 여러 작업이 한번에 실행되는 것처럼 보이지만, 실제로는 하나의 CPU에서 처리하고 있는 것입니다.
    - 이 외에도 이벤트 루프 등으로 구현할 수 있습니다. 이에 대한 내용은 검색해보시면 좋을거 같습니다.
- 병렬성(Parallelism)은 여러 개의 CPU로 여러 작업을 빠르게 처리하는 것입니다.
    - 여러 작업이 실제로 여러 개의 CPU를 통해 한번에 처리 됩니다.
- 멀티 쓰레딩은 하나의 프로세스에서 여러 개의 쓰레드를 사용하는 것입니다.
    - 쓰레드간 하나의 프로세스의 메모리 공간을 공유합니다.
    - 멀티 프로세싱보다 메모리 공간을 적게 쓰고, 컨텍스트 스위칭도 빠릅니다.
    - 하지만 동시성과 안정성에 대한 단점이 있습니다.
- 멀티 프로세싱은 하나의 프로세스에서 여러 프로세스를 사용하는 것입니다.
    - 각 프로세스는 독립된 메모리 공간을 사용합니다.
    - 동시성과 안정성에 대한 장점을 가지지만, 멀티 쓰레딩보다 메모리 공간을 많이 쓰고, 컨텍스트 스위칭도 느립니다.
- 멀티 쓰레딩과 멀티 프로세싱은 동시성과 병렬성의 구현 방법입니다.
- 병렬성을 가지면서 동시성을 가질 수도 있습니다.
    - 멀티 프로세싱을 하도록 구현함과 동시에, 각 프로세스에서 멀티 쓰레딩을 하도록 구현하면 병렬성과 동시성 모두 가져가는 셈입니다.

<br>

## 더 읽어보면 좋을 내용

- [raejoonee 님 블로그 - 프로세스와 스레드의 차이](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)
    - 쓰레드와 프로세스의 차이를 아직 모르시는 분이라면, 이 두 개념을 꼭 제대로 이해하고 가셔야합니다. 위 글에서 친절하게 설명해주고 있습니다.
