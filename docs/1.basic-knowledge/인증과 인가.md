# 인증과 인가

페이스북을 사용하려면 페이스북에 로그인해야 합니다. 로그인한 이후에 내 글을 마음대로 올리고 수정할 수 있지만, 타인이 올린 글은 맘대로 수정할 수 없습니다. 또 때론 접근이 허용되지 않는 페이지들도 존재하곤 합니다. 이렇게 사용자와 사용자의 권한을 확인하는 일을 인증과 인가라고 합니다. 이번 장에서 인증, 인가에 대해 간략히 알아봅시다.

<br>

## 쿠키와 세션

인증 인가에 대한 이야기를 하기 전에 먼저 쿠키와 세션에 대한 개념을 알아봅시다.

<br>

### 쿠키와 세션의 등장 배경

HTTP 프로토콜의 특징으로  Connectionless와 Stateless가 있습니다. 한번의 HTTP 통신으로 요청과 응답이 오간 이후에 통신을 끊는다는 것(Connectionless)이고, 이로 인해 통신과 관련된 상태는 남지 않습니다(Stateless).
예를 들어, 사용자가 로그인 요청을 한 뒤 응답을 받았다고 하더라도, 다음 요청에 이렇게 로그인된 정보는 통신 어디에도 남지 않습니다. 따라서 서버 입장에서는 어떤 요청이 있을 때 이 요청이 어떤 사용자의 요청인지 알 수 없습니다.

이렇게 Stateless한 HTTP 통신의 환경의 문제를 세션과 쿠키를 활용해서 해결할 수 있습니다.

<br>

### 쿠키

쿠키는 브라우저가 사용하는 임시 저장소 중 하나입니다. (다른 종류로는 로컬 스토리지, 세션 스토리지 등이 있습니다.) 실제로는 브라우저 사용자 컴퓨터의 로컬 스토리지에 저장됩니다.

쿠키는 Key - Value 형태이며 유효기간을 가진 데이터입니다. 또한 도메인(웹 사이트) 별로 쿠키를 다양하게 둘 수 있습니다.
크롬 브라우저에서 개발자 도구 - Application 탭을 확인해보면 다음처럼 쿠키의 형태를 확인할 수 있습니다.

![image-20210809211329408](./images/image-20210809211329408.png)



쿠키는 보통 다음처럼 사용됩니다.

- 서버 세션 관리
- 트래킹 (행동, 패턴 분석)
- 사용자 개인화

특히 인증/인가를 위해 자주 사용되는데, 이에 대한 내용은 아래에서 다룹니다.

<br>

### 세션

세션은 클라이언트와 서버간의 네트워크 연결에 대한 정보를 담고있는 객체입니다. HTTP 통신이 Stateless 하기 때문에, Stateful한 정보를 담는 별도의 객체라고 보면 되겠습니다. 세션은 보통 서버에서 생성하고 관리합니다.

세션도 쿠키와 비슷하게 Key - Value 형태로 둘 수 있습니다. 예를 들면 다음처럼 말이죠.

```json
"session_id": {
    "user_id": "grab",
    "role": "Admin",
    "created_at": "2021-08-11 18:32:01",
    "expire_time": "2021-08-11 19:32:01",
}
```

일반적으로 서버에서는 세션을 관리할 때 ID로 관리하고, 접속 시간에 제한을 두곤 합니다. 클라이언트가 서버와 연결을 시도하면 해당 연결에 대한 정보를 세션 저장소에서 찾습니다. 세션 저장소에 존재 하지않다면 새로운 세션을 만들고 저장합니다. 그리고 클라이언트에게 생성된 세션 정보를 쿠키를 이용해 넘깁니다. 그러면 클라이언트는 해당 정보를 저장하고 있다가, 이후 요청에 세션 정보를 포함하여 요청을 보냅니다. 이렇게 세션은 서버 쪽에서 관리하는 객체로, 클라이언트와 연결에 대한 정보를 담습니다.

세션 역시 인증/인가을 위해 주로 사용됩니다. 이에 대한 내용은 아래에서 다룹니다.

> *** 세션과 쿠키의 차이**
>
> 세션과 쿠키의 가장 큰 차이는, 인증에 대한 정보를 어디에 저장하느냐에 있습니다.
> 쿠키는 이 정보를 클라이언트 쪽에 저장합니다. 즉 인증 절차에 대한 모든 정보가 클라이언트에 저장한 쿠키에 있습니다.
> 세션은 이 정보를 서버 쪽에 저장합니다. 즉 인증 절차에 대한 모든 정보가 서버쪽에서 관리하는 별도의 세션 저장소에 있습니다.

<br>

## 인증

인증(Authentication)은 요청을 보내는 사용자가 등록된 사용자인지, 누구인지 식별하는 일입니다.
클라이언트 입장에서는 회원가입, 로그인 페이지와 같이 사용자를 식별하는 도입부분이 되고, 서버 입장에서는 요청을 보낸 사용자를 식별하는 부분이 됩니다.

예를 들어, 게시판을 생각해봅시다. 회원가입을 하고 글을 쓴 뒤 서버에 저장 요청을 하려고 합니다. 이 때 서버 입장에서는 이 글을 쓴 계정이 누구이며, 등록된 사용자인지 어떻게 알까요? 이를 검증하고 식별하는 일이 바로 인증입니다.

그렇다면 인증의 방법은 어떤 것들이 있을까요?

<br>

### 요청 메시지 활용하기

가장 간단한 방법은 서버로 보내는 요청 메시지에 계정 정보를 넣어 보내는 것입니다. 예를 들면 다음처럼 말이죠.

```
user_id: grab
password: 1234
title: 인증과 인가에 대한 정리 글
message: 인증은 사용자가 등록된 사용자인지 검증하며, 식별하는 일입니다...
```

서버는 요청 메시지에서 `user_id` 와 `password` 를 보고 서버에 등록된 사용자인지 확인할 수 있습니다. 이후 해당 계정으로 게시글을 생성해줄 것입니다.

이 방법은 아주 간단하지만, 요청 메시지에 계정 정보가 그대로 드러난다는 큰 문제가 있습니다. 요청 메시지는 네트워크에 있는 누군가가 쉽게 볼 수 있죠. 비밀번호를 그냥 대놓고 노출하는 방식이라고 볼 수 있습니다.
또 다른 문제는, 서버로 보내는 요청 메시지에 매번 `user_id` 와 `password` 를 포함시켜줘야한다는 것입니다. 사용자 입장에서 매우 불편합니다.

위와 같은 이유로 이 방법은 보통 사용되지 않습니다.

<br>

### 브라우저 저장소(쿠키) 활용하기

두 번째 방법은 브라우저에서 제공해주는 저장소를 활용하는 것입니다. 브라우저 저장소로 로컬 스토리지, 세션 스토리지, 쿠키 등이 있는데, 여기서는 쿠키를 사용합니다. 쿠키는 브라우저에서 관리해주는 임시 저장소라고 보시면 됩니다.

쿠키를 사용하는 방법은 다음과 같습니다.
1. 먼저 사용자는 로그인 페이지에서 다음처럼 계정 정보를 요청 메시지에 담아 서버에 요청을 보냅니다.

```
user_id: grab
password: 1234
```

2. 그럼 서버는 이 정보를 받아 등록된 사용자임을 확인하고, 응답 메시지에 브라우저 쿠키에 위 정보를 포함한 인증 정보를 담으라는 메시지를 담아 응답합니다.
3. 응답을 받은 클라이언트는 이 데이터를 브라우저 쿠키에 저장합니다.
4. 이후 클라이언트는 서버로 요청을 보낼 때마다 이 쿠키를 함께 실어보냅니다. (쿠키에 넣어두면 서버로 요청할 때마다 브라우저가 요청 메시지 헤더에 쿠키를 넣어주게 됩니다.) 이후 서버는 이 쿠키에 담긴 데이터로 사용자 인증을 하게 됩니다.

이 방법으로, 우리는 매번 요청에 계정 정보를 담아야하는 귀찮은 작업을 하지 않아도 됩니다.

그러나, 여전히 계정 정보가 쿠키에 그대로 드러나있습니다. 모든 요청에 내 계정 정보가 노출되어 있습니다.
또한 쿠키는 지워주지 않는한 내 컴퓨터에 계속해서 쌓이게 됩니다. 누군가 내 컴퓨터를 해킹한다면 쿠키를 통해 내 계정 정보를 알 수 있습니다.

따라서 이 방법 역시 그리 좋은 방법은 아닙니다.

> *** 쿠키만으로도 충분한 경우**
>
> 위 방법처럼 쿠키를 잘 활용하는 경우도 있습니다. 딱히 계정 정보와, 인증이 필요없는 경우입니다.
> 예를 들어 웹 쇼핑몰의 장바구니같은 시스템이 이렇습니다. 이런 사이트들은 보통 로그인을 하지 않아도(비회원으로) 장바구니에 물건 담기가 가능합니다. 이런 시스템은 별도의 인증을 거치지 않지만, 브라우저에 담긴 쿠키로 개별 회원들을 어느정도 구분합니다.
> 이렇게 쿠키는 꼭 인증을 목적으로 쓰이지 않고, "임시 저장소"로서 폭넓게 사용됩니다.

<br>

### 쿠키에 세션까지 활용하기

쿠키에 내 계정 정보가 그대로 드러나지 않게 하고싶습니다.
이에 대한 방법으로 서버에서 세션이라는 개념을 만들어 활용할 수 있습니다.

![Use of session cookies vs jwt for authentication](https://www.hebergementwebs.com/image/6e/6e1b139c21f317b2a78a3e8b6d51d9e3.webp/use-of-session-cookies-vs-jwt-for-4.webp)

(출처: https://www.hebergementwebs.com/news/use-of-session-cookies-vs-jwt-for-authentication)

세션을 사용하는 방법은 쿠키를 사용하는 방법과 유사합니다.

1. 사용자는 쿠키를 사용하는 때와 똑같이 로그인 페이지에서 계정 정보를 다음처럼 요청 메시지에 담아 서버에 요청을 보냅니다.

```
user_id: grab
password: 1234
```

2. 서버는 이 계정 정보를 받아 유효한 계정인지 확인한 후, "세션"이라고 하는 객체를 만들어 유저 정보와 접속 시간 등 연결에 대한 정보를 이 객체에 담습니다. 그리고 세션을 세션 저장소에 저장합니다.
3. 그리고 응답 메시지에 다음처럼 생성한 세션 ID를 담아 클라이언트에게 응답합니다.

```
session-id: 12345
```

4. 응답을 받은 클라이언트는 이 데이터를 마찬가지로 브라우저 쿠키에 저장합니다.
5. 이렇게 되면 이제 클라이언트와 서버는 그대로 드러나는 계정 정보가 아닌 세션 ID를 주고 받게 되고, 서버는 이 세션 ID로 인증을 진행하게 됩니다. 서버는 요청을 받을 때마다 세션 저장소에서 세션 ID를 찾고, 유효한 세션 ID인지 확인합니다. 만약 유효하다면 인증에 성공하는 것이고, 유효하지 않다면 인증에 실패한 것입니다.

이 방법으로 우리는 우리 계정 정보를 쿠키에 그대로 노출시키지 않습니다. 또한 세션은 인증의 유효기간을 서버에서 관리하기 때문에 어느정도 시간이 지나면 기존의 세션 ID는 인증에 실패합니다. 즉 주기적으로 다시 로그인을 하여 유효한 세션 ID를 발급받아야 합니다.

세션은 기존의 "쿠키만" 사용하는 것보단 보안적으로 좋습니다. 하지만 이제 인증에 필요한 데이터들을 서버에서 관리하기 때문에 서버에 부하가 생기게 됩니다. "쿠키만" 사용할 때는 개별 클라이언트의 컴퓨터에서 이 데이터들을 관리하여서 서버에 부담이 없었습니다. 하지만 "세션"을 사용하는 서버는 세션을 위한 저장소를 만들어야하고, 기존보다 좀 더 많은 일을 하게 됩니다. 유저 트래픽이 아주 많은 서비스는 이게 매우 부담스럽게 됩니다.

<br>

### 토큰을 사용하기

세션이 문제가 되던 이유는 서버에서 별도의 "저장소"를 관리해야 하기 때문입니다. 이 때문에 인증하는 과정이 조금 복잡해지고 느려집니다.
토큰은 별도의 저장소를 사용하지 않고, "토큰"이라고 하는 하나의 문자열에 인증에 필요한 데이터를 모두 담는 방법입니다. 토큰은 여러 종류가 있으나,  JWT(Json Web Token)이 가장 흔하게 사용됩니다.

토큰을 사용하는 방법은 다음과 같습니다.
1. 사용자는 로그인 페이지에서 계정 정보를 다음처럼 요청 메시지에 담아 서버에 요청을 보냅니다.

```
user_id: grab
password: 1234
```

2. 서버는 이 계정 정보를 받아, 유효한 사용자인지 확인한 후 다음처럼 유저 정보와 인증에 필요한 데이터를 문자열로 인코딩하여 만듭니다. (이 문자열을 토큰이라 합니다.)

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

3. 토큰은 인증에 필요한 정보를 담아 암호화된 문자열인데, 이 문자열을 해독(decode)하면 인증에 필요한 정보를 다 얻을 수 있습니다. 예를 들면 위 코드를 해독하면 다음과 같은 데이터가 나오게 됩니다.

```
user_id: grab
role: Admin
created_at: 2021-08-11 18:32:01
```

4. 서버는 응답 메시지에 위 토큰을 담아 응답하고, 클라이언트는 이를 받은 뒤 서버에게 요청할 때마다 이 토큰을 사용하여 인증을 진행합니다.

이 방법은 세션처럼 별도의 세션 저장소를 필요로 하지도 않고, 세션 ID를 생성하고 조회하는 로직도 필요하지 않습니다. 따라서 인증을 처리하는 방식이 훨씬 가볍습니다. 그리고 토큰에 인증뿐 아니라 뒤에서 설명할 인가에 대한 정보까지 모두 넣을 수 있습니다.

하지만 토큰에 많은 데이터를 저장할수록 토큰이 커져 요청 속도가 느려집니다. 또한 백엔드 로직에서 사용자 계정에 대한 정보가 필요한 경우, 이 토큰을 해석하는 로직을 항상 호출해야 합니다.

> *** 쿠키/세션 vs 토큰, 언제 사용해야 할까?**
>
> 세션/쿠키는 사용자별 기본 테마와 같은 개인화 설정이 필요할 때 쓸 수 있습니다. 또한 쿠키로 사용자의 행동 이력을 기록 및 추적할 수 있습니다. 이처럼 세션/쿠키는 단순 인증 이외에 사용자에 대한 더 많은 정보를 한번에 담아서 사용해야할 때 쓰입니다.
>
> 한편 토큰은 쿠키/세션보다 사용환경이 좀 더 범용적입니다. 세션/쿠키는 웹 브라우저 통신에서만 가능한 한편, 모바일 환경에서는 불가능합니다. 따라서 토큰은 API가 웹, 모바일, IoT 등 다양한 플랫폼에서 사용될 때 유용합니다. 또한 토큰은 서로 다른 도메인에 있는 서버간 인증을 해야하는 경우에도 유용합니다. 따라서 마이크로 서비스 환경에서 주로 쓰입니다.

> *** OAuth, 외부 서비스에 위임하기**
>
> 위의 방법들을 사용할 때, 사용자 입장에서는 하나 찜찜한 구석이 있습니다. 바로 자신의 계정 정보, 특히 패스워드와 같은 보안 정보를 특정 서비스의 서버에 저장한다는 것입니다. 사용자는 이 서비스가 네이버나 구글과 같이 뭔가 믿을만한 서비스도 아니며, 서버가 보안적으로 취약한 상태인지 알 수 없습니다. 따라서 자신의 보안정보를 온전히 이 서비스에 맡기는게 찜찜합니다.
>
> 이러한 사용자의 찜찜함을 해소하기 위해 인증을 외부 서비스에 위임하는 OAuth 방법이 등장하게 되었습니다. 우리가 로그인 화면에서 흔히 보는 "네이버 계정으로 로그인", "구글 계정으로 로그인" 와 같은 방법이 바로 이 방법입니다.
>
> ![img](./images/99115C3F5B6EECBF37.png)
>
> (출처: https://tansfil.tistory.com/60#comment6188294)
>
> 이 방법은 서버가 직접적으로 로그인 정보를 받지 않습니다. 서버에 로그인 요청이 올 때 네이버나 구글과 같은 외부 서비스에 로그인을 위임하며, 사용자는 네이버나 구글을 통해서 로그인합니다. 그리고 서버는 이 외부 서비스에서 인증을 통해 발급된 토큰을 전달받은 뒤, 응답 메시지에 토큰을 담아 사용자에게 응답합니다.
> 사용자는 매 요청 메시지에 이 토큰을 담아 서버에 요청하게 되고, 서버는 이 토큰을 다시 외부 서비스에 요청하여 인증이나 인가에 필요한 처리합니다.
>
> 현대의 대부분 웹 서비스가 이 방식을 사용하고 있습니다.

<br>

## 인가

인가(Authoirzation)는 인증을 마친 사용자가 요청에 대해 유효한 권한을 가지고 있는지 확인하는 작업입니다.
예를 들어, 게시판에서 일반 계정은 자신의 글만 수정하고 지울 수 있습니다. 남의 글을 수정하거나 지울 수 있는 권한이 없죠. 하지만 관리자 사용자는 모든 계정의 글을 수정하고 지울 수 있는 권한이 있습니다. 이처럼 인증된 계정 사이에도 "권한"이 다른 경우가 있습니다. 인가는 바로 이럴 때 사용됩니다.

인가의 방식은 크게 다음 2가지가 대표적입니다.

- RBAC (Role Based Access Control)
- ACL (Access Control List)

<br>

### RBAC

다음처럼 계정, 권한과 롤이라는 개념을 만들어두고, 이에 기반으로한 접근 제어 방법입니다.

![img](https://t1.daumcdn.net/cfile/tistory/255F0940542422D031)

(출처: https://bcho.tistory.com/955)

<br>

### ACL

롤이라는 개념을 따로 두지 않고 계정과 권한만으로 접근을 제어하는 방법입니다.

![img](https://t1.daumcdn.net/cfile/tistory/26073B40542422CD08)

(출처: https://bcho.tistory.com/955)

> *** 인가는 어디에 구현해야할까?**
>
> 인가는 백엔드 서버 코드에 구현되기도 하며, 좀 더 규모가 있는 경우에 별도의 인증/인가 서버에서 구현하기도 합니다. 별도의 인증/인가 서버는 직접 구축하거나 Keycloak 같은 오픈소스를 활용하기도 합니다.

<br>

## 정리

- 쿠키는 브라우저가 사용하는 임시저장소 중 하나로 Key-Value 형태로 데이터를 담습니다.
- 세션은 클라이언트와 서버간의 네트워크 연결에 대한 정보를 담고있는 객체로, 서버에서 생성하고 관리합니다. 쿠키와 마찬가지로 보통 Key-Value 형태로 데이터를 담습니다.
- 인증은 사용자가 등록된 사용자인지 확인하고 식별하는 작업입니다.
    - 현대에는 인증 방식으로 쿠키/세션, 토큰 방식을 많이 활용합니다.
    - 쿠키/세션 인증방식은 세션으로 인증하는 방식입니다. 세션 ID는 쿠키에 담아 클라이언트/서버가 주고받습니다. 사용자에 대한 더 많은 정보를 담거나 트래킹해야할 때 주로 사용합니다.
    - 토큰 인증 방식은 유저 정보를 토큰이라고 하는 암호화된 문자열로 만들어 이를 주고받으며 인증하는 방식입니다. 웹 뿐 아니라 모바일 등 다양한 환경에서 쓰이도록 범용적이며, 다른 도메인 서버간  인증하는데 유용합니다.
- 인가는 인증이 완료된 사용자가 요청에 대해 유효한 권한을 가지고 있는지 확인하는 작업입니다.
    - 관리자, 일반 사용자 등 사용자별로 기능 권한을 분리해야할 때 사용합니다.
    - RBAC나 ACL와 같은 방법이 있습니다.
    - 서버 코드 내부에 구현하기도 하고, 외부에 별도로 구축하기도 합니다.

<br>

## 더 읽어보면 좋은 내용

- tansfil님 블로그 - 쉽게 알아보는 서버인증 시리즈
    - [쉽게 알아보는 서버 인증 1편(세션/쿠키 , JWT)](https://tansfil.tistory.com/58)
    - [쉽게 알아보는 서버 인증 2편(Access Token + Refresh Token)](https://tansfil.tistory.com/59)
    - [쉽게 알아보는 서버 인증 3편(SNS 로그인, OAuth 2.0)](https://tansfil.tistory.com/60#comment6188294)
- [조대협님 블로그 - REST API의 이해와 설계-#3 API 보안](https://bcho.tistory.com/955)

<br>

## 참고

- https://bcho.tistory.com/955
- https://www.section.io/engineering-education/cookie-vs-token-authentication/
