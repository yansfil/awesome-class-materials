# 가상화 기술과 도커



<br>

## 가상화 기술

### 등장 배경

가상화 기술이란 하드웨어 리소스를 추상화하여 소프트웨어화 하는 기술을 말합니다. 예를 들어 우리는 가상화 기술을 통해 "CPU 1코어, Memory는 2Gi , 운영체제는 Ubuntu:16.04" 인 소프트웨어를 만들 수 있습니다. 실제로 이런 예의 대표적인 사례가 바로 AWS나 GCP, AZURE와 같은 클라우드 서비스입니다.

가상화 기술의 등장 이전에는 소프트웨어는 하드웨어에 크게 종속되었습니다.
그래서 아래와 같은 문제들이 있었습니다.

- 하나의 서비스를 제공하기 위해서는 하나의 컴퓨터 전체에 서버 프로그램을 띄워서 사용해야만 했습니다. 사용량이 적은 서비스더라도 컴퓨터의 CPU, Memory 등의 리소스를 전부 사용할 수 밖에 없었습니다.
- OS나 하드웨어의 특징에 따라 소프트웨어의 동작에 영향을 끼쳤습니다. 예를 들면 리눅스 컴퓨터에 서버를 운영하고 있는 회사에서 개발자들이 Window 컴퓨터, Mac 컴퓨터를 사용한다면 "내 컴퓨터에서는 됐지만 여기서는 왜 안돼"를 시전할 수 있게 됩니다.

그러나 가상화기술이 나오면서 이런 문제점들은 자연스럽게 해결되었습니다.
- 하드웨어 리소스도 추상화되었기에 서비스에 자원을 자유롭게 할당할 수 있습니다.
- OS에 관계없이 동일한 환경에서 소프트웨어를 구동할 수 있습니다.

실제로 클라우드(AWS, GCP 등)에서 우리가 사용하는 대부분의 서비스는 내부적으로 가상화 기술이 도입되어 있습니다.
우리가 클라우드에서 컴퓨팅 리소스를 빌릴 때 컴퓨터 한 대를 빌리는 게 아닌, 특정 리소스만큼 할당된 가상화 공간을 제공받는거죠.

### VM (Virtual Machine)

![blog/virtual-machine-architecture.jpg](https://nickjanetakis.com/assets/blog/virtual-machine-architecture-e6bcc9d42a12a12da38e92ba5a7ddef21e6bda269abc580a84ece64ac189d2b2.jpg)

(출처: https://nickjanetakis.com/blog/comparing-virtual-machines-vs-docker-containers)

VM은 하드웨어를 가상화하는 기술 중 하나입니다. 컴퓨터에 기본적으로 설치한 OS(Host OS) 위에 Hypervisor라는 소프트웨어를 통해 여러 OS(Guest OS)를 띄우고 컴퓨팅 리소스를 제어할 수 있습니다. 그리고 이렇게 만든 각각의 환경에서 애플리케이션을 독립적으로 실행할 수 있습니다.
예를 들어, VM으로 여러분이 사용하는 Window OS환경에서 별도의 Window, Mac OS, Linux 등의 OS를 동시에 올려두고 각 cpu, memory 사용량 등을 조정할 수 있습니다. 이렇게 하나의 컴퓨터로도 여러 개의 독립된 하드웨어 환경을 격리시켜 실행하는 것이 가능합니다.

그러나 VM의 가장 큰 단점이 있는데 바로 용량입니다. VM은 운영체제를 비롯한 실행 환경에 필요한 파일들을 "이미지" 라는 형태로 저장하고 있습니다. 그런데 이 이미지의 용량 자체가 꽤 큽니다. 따라서 VM으로 여러 가상환경을 운영하면, VM으로만으로도 많은 리소스가 낭비됩니다. (보통 이런걸 무겁다라고 표현합니다.)

또 하나의 단점은 실행환경의 부가적인 설정들을 완전히 구현하기 어려웠다는 점입니다. 예를 들어 우리가 실행 환경을 위해 리눅스 이미지를 사용하여 VM 가상환경을 구축한다고 해봅시다. 실제로 서버를 실행하려면 리눅스 이미지 위에 이런저런 라이브러리 설치를 더해주어야 하는데, 이런 내용이 이미지에 들어가있지는 않습니다. 따라서 단순히 "이미지"만 가지고 실행환경을 완전히 구현하기 어려웠습니다.

<br/>

### Docker (Container)
VM이 너무 무겁다는 불만이 나오는 가운데 Docker라고 하는 것이 등장합니다. Docker는 VM과 마찬가지로 실행환경을 가상화하여 실행시킬 수 있는 도구인데, VM보다 리소스를 덜 쓰며 훨씬 가볍습니다. VM에서는 "이미지"를 만드는 것이 시간이 오래걸리고 용량도 큰 작업이었는데, Docker에서는 비교적 빠르고 용량도 가볍습니다. Docker에서는 이 이미지를 "컨테이너 이미지"라고 부르는데, 누구나 쉽게 만들 수 있습니다.

도커를 사용하는 예시를 간단하게 살펴보겠습니다.
다음처럼 파이썬을 실행 환경을 만들고, 파이썬 코드를 실행하는 컨테이너 이미지를 만들 수 있습니다. (아래 코드는 `Dockerfile` 이라는 파일에 담깁니다.)

```Dockerfile
# 파이썬 코드를 실행하는 컨테이너 이미지를 만듭니다.
# 리눅스 우분투 컨테이너 이미지를 기반으로 만듭니다. (기반이 되는 이미지를 베이스 이미지라고 합니다.)
FROM ubuntu:18.04

# 리눅스 우분투 환경에 파이썬을 설치합니다.
RUN apt-get update -y
RUN apt-get install -y python-pip python-dev build-essential

# 우리가 작성한 파이썬 코드를 설치하고 실행합니다.
COPY . /app
WORKDIR /app
RUN pip install -r requirements.txt
ENTRYPOINT ["python"]
CMD ["app.py"]
```

위에서는 베이스 이미지로 `ubuntu:18.04` 를 사용했지만, 다음처럼 파이썬이 이미 설치되어 있는 컨테이너 이미지를 베이스 이미지를 사용할 수도 있습니다.

```Dockerfile
# 파이썬 코드를 실행하는 컨테이너 이미지를 만듭니다.
# 파이썬 3.8 컨테이너 이미지를 베이스 이미지로 사용합니다.
FROM python:3.8

# 우리가 작성한 파이썬 코드를 설치하고 실행합니다.
COPY . /app
WORKDIR /app
RUN pip install -r requirements.txt
ENTRYPOINT ["python"]
CMD ["app.py"]
```

이후 다음처럼 도커 명령어로 위 `Dockerfile` 파일을 가지고 이미지를 만듭니다. (이를 보통 빌드한다고 합니다)

```bash
$ docker build . -t my-app
```

이렇게 만든 이미지는 다음처럼 도커 명령어로 확인할 수 있습니다.

```bash
$ docker images
REPOSITORY                   TAG                        IMAGE ID       CREATED        SIZE
my-app                       latest                     828b1334ba8f   24 hours ago   305MB
```

이렇게 만든 이미지는 다음처럼 실행 가능합니다.

```bash
$ docker run my-app
```

Dockerhub라고 하는 컨테이너 이미지 저장소에 이렇게 사용할 수 있는 컨테이너 이미지가 널려있습니다. 이렇게 공개되어 있는 컨테이너 이미지로 나만의 컨테이너 이미지를 만들 수 있고, 자신이 만든 컨테이너 이미지를 이미저 저장소에 공개할 수도 있습니다.

![불좀 꺼줄래? 내 Docker좀 보게 PART 4 - 실전 연습 - Docker hub 사용하기](https://d2uleea4buiacg.cloudfront.net/files/fa2/fa204630bed1deaf4e18a19a180f885934b613c6293584180ef1412fe8ed5283.m.png)

(Dockerhub 사이트: https://hub.docker.com/)

예를 들어 Dockerhub에 공개된 mysql 5.8 이미지를 사용하고 싶으면 다음처럼 docker 명령어를 입력하면 됩니다.

```bash
$ docker pull mysql:5.8
$ docker run mysql:5.8
```

이를 통해 컴퓨터에 손쉽게 mysql을 실행시킬 수 있습니다.

![Containers vs. Virtual Machines (VMs): What&#39;s the Difference? | NetApp Blog|Containers  vs. Virtual Machines (VMs): What&#39;s the Difference? | NetApp Blog](https://www.netapp.com/media/Screen-Shot-2018-03-20-at-9.24.09-AM_tcm19-56643.png)

(출처: https://www.netapp.com/blog/containers-vs-vms/)

Docker를 사용하면 다음과 같은 장점이 있습니다.

- VM보다 가벼우면서도 독립적인 실행환경을 갖출 수 있습니다.
    - docker는 VM과 다르게 Guest OS를 가지지 않도록 기술적으로 구현되었습니다. 이 점이 도커가 VM보다 가볍고 빠른 대표적인 이유입니다.
- `Dockerfile` 내에 실행하기 위한 모든 설정이 기록되어 있기 때문에, Docker 문법을 아는 사람이라면 쉽게 실행환경을 이해할 수 있고 재현할 수 있습니다.
- `Dockefile` 에 작성된 설정 말고는 별다른 의존성이 없습니다. 따라서 도커가 설치된 어느 컴퓨터에서든 도커 이미지를 실행시키면 동일한 실행환경위에 소프트웨어를 실행시킬 수 있습니다.

<br>

# 2. 배포와 CI/CD

<br>

## 배포

우리가 웹 사이트 개발자라고 해봅시다. 우리는 코드를 작성한 뒤, 나름대로 테스트까지 마쳤습니다. 그리고 이제 인터넷으로 사용자들 이 웹 사이트에 접속하게 만들고 싶습니다. 어떻게하면 사람들이 내가 만든 웹사이트에 접속하게 할 수 있을까요?

가장 간단한 방법은 인터넷이 연결되어있는 컴퓨터를 하나 산 뒤, 이 컴퓨터에 웹서버와 내 웹사이트를 실행시키는 것입니다. (보통 이 컴퓨터를 서버라고 부릅니다.) 실제로 [카페24](https://www.cafe24.com/?utm_source=google&utm_medium=cpc&cafe_mkt=google_kw&gclid=Cj0KCQjwu7OIBhCsARIsALxCUaNGgStgYXZh2WiFlzAHTKt-BUgZWjy8fVfa6_O9BdpaUbnaNdsg8TMaAo63EALw_wcB)와 같이 컴퓨터를 빌려주는 웹 호스팅 서비스와, 도메인 구매를 할 수 있는 가비아 도메인 등록 서비스를 사용하면 이렇게 내 웹사이트를 인터넷에 공개할 수 있습니다.

이렇게 내가 만든 작업물을 외부 환경에 공개하는 일을 "배포"라고 합니다.
좀 더 예를 들면, 새로운 모바일 앱을 앱스토어에 등록하는 것도 배포입니다. 기존에 있던 웹 서비스를 업데이트하는 작업도 배포라고 할 수 있습니다.

<br>

## 배포 방법의 변화

그렇다면 배포는 보통 어떻게 할까요?
시간이 흐름에 따라 배포 방법도 많은 변화가 있었는데, 이에 대해 간략히 살펴봅시다.

### 직접 소스코드 설치 & 배포하기

아주 초기에는, 서버에 직접 코드를 설치했습니다. 예를 들면 디스크나 CD, 지금으로 치면 USB 같은 디스크에 소스 코드를 담아, 서버가 있는 곳으로 가서 소스 코드를 직접 다운받아 실행시키는 것이죠. 배포는 할 수 있으나, "서버가 있는 곳까지 소스 코드를 들고 매번 가야하는 불편함"이 존재했습니다.

### FTP나 원격저장소로 설치 & 배포하기

인터넷의 발달로 이제 인터넷을 통해 서버에 접속할 수 있게 되었습니다. 이제 직접 코드를 들고 컴퓨터가 있는 곳까지 가지 않고, FTP를 통해 서버에 소스 코드를 업로드합니다. 또는 GitHub와 같은 코드 원격 저장소를 통해 작업한 코드를 업로드하고, 서버에서 다운받아 설치합니다. 이후 서버에 접속하여 소스 코드를 실행시켜 배포합니다. 이전보다 훨씬 편해졌습니다.

하지만 서버가 여러 대인 경우, 이런 작업을 서버 개수만큼 해야하는 불편함은 여전히 존재했습니다. 또한 서버의 운영체제나 환경설정에 따라 내가 작성한 소스 코드가 실행되지 않는 일도 발생했습니다. 예를 들어 윈도우 환경에서 하고 코드를 개발하고 테스트할 때까지만 하더라도 문제가 없었는데, 서버의 운영체제인 리눅스에서 실행하면 문제가 발생하는 것입니다.

한 서버에 여러 개의 서비스를 실행할 때도 문제가 되었습니다. 예를 들어 서버에 A라는 서비스가 실행되고 있었다고 합시다. B라는 서비스를 이 서버 위에 또 배포하고 싶어 B 코드를 설치합니다. 이 때 B를 설치하는 과정에서 A라는 서비스가 사용하고 있던 운영체제의 설정이 바뀌거나, 라이브러리가 바뀌는 부작용이 발생할 수 있습니다. 두 서비스는 독립적인 서비스인데, 같은 실행 환경을 공유하고 있기 때문에 이런 현상이 발생하게 된 것입니다.

이 때문에 이제 "코드를 실행하는 환경"과 "배포의 독립성" 이 중요한 이슈로 떠오르게 됩니다.

### VM 위에서 배포하기

VM 등장 이후 이제 배포에 VM을 적극 활용하게 됩니다. VM을 사용하면 윈도우 환경에서 개발해도, 실제 서버에 배포 하기 전에 VM으로 리눅스 환경을 구축하여 이 위에서 실행을 테스트 해볼 수 있게 됩니다. 그리고 서버에도 마찬가지로 VM을 사용하여 테스트했던 환경과 똑같은 운영체제 환경을 구축할 수 있습니다. 이럼으로써 "코드를 실행하는 환경"을 어느정도 일관되게 가져갈 수 있었습니다.

### 컨테이너 기반(Docker)으로 배포하기

도커는 VM 이후에 등장합니다. 그리고 VM보다 가벼운 도커를 배포에 더 적극적으로 활용하게 됩니다.
현재 IT 회사에서 이뤄지는 대부분의 배포는 Docker를 통해 이루어지게 됩니다. 구체적으로는 다음의 과정을 거칩니다.

- 먼저 코드 개발을 완료합니다.
- 이제 배포를 할 단계입니다. 위처럼 `Dockerfile` 을 작성합니다.
- `docker build` 명령어를 입력하면 위 `Dockerfile` 을 읽어 컨테이너 이미지를 만들게 됩니다. (보통 이를 "빌드"라고 표현합니다.)
- Dockerhub와 같은 컨테이너 이미지 저장소에 방금 만든 컨테이너 이미지를 업로드 합니다.
- 배포할 서버에 접속하여, `docker run {컨테이너 이미지 이름}` 으로 업로드한 컨테이너 이미지를 다운받은 뒤 실행합니다.

Docker를 사용하면 VM보다 가벼우면서도 독립적인 실행환경을 갖출 수 있습니다. 또한 `Dockerfile` 내에 실행하기 위한 모든 설정이 기록되어 있기 때문에, Docker 문법을 아는 사람이라면 쉽게 실행환경을 이해할 수 있고 재현할 수 있습니다.

Docker의 이런 혁신적인 장점 때문에 현재 소스 코드를 배포하는데 Docker가 폭발적으로 쓰이고 있습니다.

<br>

## CI/CD

Docker로 인해 배포가 굉장히 편해져 이전보다 배포하는 속도는 매우 빨라지고 배포를 더욱 자주하게 되었습니다. 하지만 사람들은 더 자주, 더 빨리 배포하고 싶어했습니다. 배포에서 다음 과정들은 여전히 사람이 해야하는 수동적인 과정이었습니다.

- Docker 컨테이너 이미지를 빌드하는 과정
- 빌드된 컨테이너 이미지를 저장소에 업로드하는 과정
- 업로드한 컨테이너 이미지를 서버에서 다운받아 실행하는 과정

이제 이 과정까지 자동화하면 좋겠다는 생각에 이르게 됩니다. 예를 들면 내가 작업한 코드를 GitHub에 올리게 되면, 그 즉시 위 세 과정이 순차적으로 동작하도록 할 수 있습니다. 즉 내가 GitHub에 개발한 코드를 올리면, 바로 배포가 되는 것입니다. 이렇게 하면 개발과 배포가 막힘이 없이 연속으로 이루어지게 됩니다. 이것을 지속적 통합/지속적 배포(Continous Integration / Continous Deployment, 일명 CI/CD)라고 부릅니다.

> ***CI (Continous Integration)**
>
> CI/CD에서 CD는 주로 "배포"를 의미하는 한편, CI는 주로 "테스트와 빌드"를 의미합니다. 위 내용에서 "테스트"에 대한 내용은 포함하지 않았는데 실제 현업에서는 테스트에 대한 내용까지 포함합니다. 즉 코드를 개발하면 자동으로 "테스트"하고, 테스트를 통과한 후에는 "빌드"함으로써 코드를 개발해나갈 때 지속적으로 문제없이 코드를 "통합"해나가는 것입니다.

![Beginner&#39;s Guide to CI/CD Pipeline From Scratch - DZone DevOps](https://www.edureka.co/blog/content/ver.1531719070/uploads/2018/07/Asset-33-1.png)

(출처: https://www.edureka.co/blog/content/ver.1531719070/uploads/2018/07/Asset-33-1.png)

CI/CD 도구로는 Jenkins, CircleCI, Travis, Github Action, BuddyWorks와 같은 것들이 있습니다. CI와 CD를 한번에 다루어 사용하기도 하며, 경우에 따라서 분리하여 사용하기도 합니다.

![API Testing Automation and CI/CD Tools - API Fortress](https://apifortress.com/wp-content/uploads/2020/12/CICDlogos.png)

(출처: https://apifortress.com/wp-content/uploads/2020/12/CICDlogos.png)

이러한 CI/CD 개념과 도구 덕분에 개발자들은 더욱 빠르게 배포할 수 있었습니다. 빠르게 배포 후 빠르게 피드백을 받으니 개발 진척 속도도 더 빨라지게 되었습니다.

> 회사에서 이런 CI/CD 업무는 보통 데브옵스 엔지니어가 담당합니다. 아직 데브옵스 엔지니어 팀이 없거나, 업무가 분담되지 않은 경우 개발자들이 직접 하기도 합니다.

<br>

## 정리

- 배포는 내가 만든 작업물을 외부 환경에 공개하는 일입니다.
- 배포 방법은 직접 설치, FTP나 원격저장소, VM을 거쳐 현재는 Docker로 하기까지의 발전 과정이 있었습니다.
- 좀 더 자주, 빠른 배포를 위해 CI/CD 개념과 도구들이 생겨났습니다.
- CI/CD로 개발과 배포를 막힘없이 진행할 수 있습니다.

<br>

## 더 읽어보면 좋을 내용

- Docker와 관련된 내용들
    - [44bits - 도커(Docker) 입문편](https://www.44bits.io/ko/post/easy-deploy-with-docker)
- [수비쿠라님 블로그 - 쿠버네티스 시작하기 - Kubernetes란 무엇인가?](https://subicura.com/2019/05/19/kubernetes-basic-1.html)
    - 쿠버네티스는 분산 환경에서의 컨테이너 오케스트레이션 툴입니다.
    - 아마 한번쯤 들어보셨을텐데, 이번 기회에 아래 수비쿠라님의 글을 통해 대략 어떤 것인지 감을 잡아보시면 좋습니다.
- CI/CD와 관련된 내용들
    - [뱅크 샐러드 블로그 - 하루에 1000번 배포하는 조직 되기](https://blog.banksalad.com/tech/become-an-organization-that-deploys-1000-times-a-day/)
    - [라인 블로그 - CI/CD 자동화가 가져다 준 행복](https://engineering.linecorp.com/ko/blog/ci-cd-automation/)
