# 전략적으로 git 사용하기 - Gitflow

이번 글에서는 프로젝트를 진행할 때 Git을 사용하는 전략 패턴 중 하나인 Gitflow 전략을 알아봅시다.

<br>

## Git의 전략적 활용

하나의 프로젝트에 여러 개발자들이 참여했다고 합시다. 이 개발자들 안에는 프론트엔드, 백엔드, QA 개발자 등 다양한 업무를 맡은 사람들이 존재합니다. 이 여러 사람들이 개발과 테스트를 할 때 어떻게 진행하면 좋을까요?

가장 간단하게는 하나의 Git 브랜치 위에서 모두가 작업하는 방법이 있습니다. 그러나 이렇게 되면 수시로 remote repository 내용은 바뀔 것이고 `pull` 할 때마다 수시로 conflict 가 날 가능성이 많습니다. 또한 브랜치에 내 작업만 있는 것이 아니라, 쉽게 `reset` 하기도 어렵습니다. 또한 내 코드만 있는게 아니기 때문에 리뷰도 불가능합니다.

좀 더 나은 방법으로는 개개인이 작업할 브랜치를 만들고 그 위에서 작업하는 것입니다. 이러면 내 작업만 해당 브랜치에 남으며, `reset` 에 대한 부담도 덜합니다. 또한 리뷰도 받을 수 있습니다. 하지만 사람들이 각자 만드는 브랜치를 관리하기 어려워집니다. 브랜치 개수는 언제든 늘어날 수 있으며, 브랜치 이름 규칙도 정해지지 않아 혼란스러워 질 수 있습니다.

Git의 전략적인 활용은 이렇게 협업함에 있어 Git을 어떻게 사용해야 보다 효율적으로 프로젝트를 운영할 수 있을지에 대한 내용입니다. 사람들은 이 Git 활용 전략에 대해 계속해서 고민하고 시도했는데, 결과적으로 대표적인 몇가지 패턴이 등장했습니다. 그중 가장 대표적인 것이 바로 Gitflow 패턴입니다.

<br>

## Gitflow란?

### 프로젝트 개발 사이클

일반적인 개발 프로젝트 과정을 생각해보면 다음과 같이 어느정도 정형화된 사이클이 있음을 알 수 있습니다.

1. 필요한 기능을 분석, 정의하고 개발합니다.
2. 개발이 완료되면 테스트 환경에 배포합니다.
3. 통합 테스트를 진행하며 버그 등 문제가 없는지 확인합니다.
4. 문제가 있으면 이를 수정하고 2~3의 과정을 거칩니다.
5. 테스트 완료 후에 최종적으로 운영 환경에 배포합니다.
6. 최종 배포 후 며칠 뒤 심각한 버그를 발견하면 빠르게 수정하여 업데이트된 프로젝트를 배포합니다.

Gitflow는 이런 사이클을 고려한 Git 전략 패턴입니다.



### Gitflow 브랜치 전략

Gitflow패턴은 다음과 같이 5개의 브랜치를 두도록 약속합니다.

- **master**
    - 운영 환경에 최종 배포가 되는 프로젝트를 담는 브랜치입니다.
- **develop**
    - 아직 배포하지는 않았지만, 기능 개발을 완료한 프로젝트를 담는 브랜치입니다.
    - master 브랜치로부터 파생됩니다.
- **feature**
    - 필요한 각 기능들을 작업하는 브랜치입니다.
    - 보통 `feature/기능` 으로 브랜치 이름을 짓습니다.
        - ex. `feature/create_user`
    - 실제 개발자들은 이 브랜치를 만들어 이 위에서 작업합니다.
    - develop 브랜치로부터 파생됩니다.
    - 해당 브랜치에서 작업을 완료하면 develop 브랜치로 머지됩니다.
- **release**
    - 최종 배포 되기 전 통합 테스트를 할 프로젝트를 담는 브랜치입니다.
    - develop 브랜치로부터 파생됩니다.
    - 테스트 중 발견한 버그 수정 역시 release 브랜치에서 이뤄집니다.
    - 테스트가 완료되면 master 브랜치와 develop 브랜치에 머지됩니다.
- **hotfix**
    - 운영 환경 중 발견된 심각한 버그를 수정할 때 사용하는 브랜치입니다.
    - master 브랜치로부터 파생됩니다.
    - 버그 수정 후 master 브랜치와 develop 브랜치에 머지됩니다.



### 브랜치 흐름

![img](https://miro.medium.com/max/1400/1*9yJY7fyscWFUVRqnx0BM6A.png)

(출처: https://medium.com/devsondevs/gitflow-workflow-continuous-integration-continuous-delivery-7f4643abb64f)

전체적인 프로젝트와 브랜치 흐름은 다음처럼 이루어집니다.

1. master 브랜치에서 develop 브랜치를 만듭니다.
2. 필요한 기능사항들을 정의하고 개발자들 별로 어떤 기능 개발을 담당할지 정합니다.
3. 기능사항 별로 각 개발자들은 develop 브랜치에서 feature 브랜치를 만들어 작업합니다.
    - 실제로는 `feature/create_user` , `feature/payment` 등 한번에 개발할 단위로 브랜치를 만듭니다.
    - 한 사람이 여러 브랜치를 담당할 수 있습니다.
    - 반대로 한 브랜치에 해당 기능 개발에 참여한 여러 사람이 작업할 수도 있습니다.
4. feature 브랜치에서 작업완료 후 remote repository에서 `push` 하여 팀원들에게 리뷰를 받습니다.
5. 리뷰가 완료된 feature 브랜치는 develop 브랜치로 머지합니다.
6. 정의했던 기능사항들을 모두 개발하고 나면 이제 develop 브랜치에서 release 브랜치를 만듭니다.
7. 이 release 브랜치 위에서 통합 테스트를 진행합니다.
    - 보통 회사 내 QA팀이 있으면 QA팀에서 이런 테스트를 진행해줍니다.
    - 통합 테스트 중 발견된 버그는 release 브랜치 위에서 수정하고 커밋합니다.
8. 통합 테스트를 마치면 master 브랜치와 develop 브랜치를 머지합니다.
9. 마지막으로 master 브랜치의 최종 커밋에 tag를 달아 프로젝트 버전을 명시합니다.
10. 이후에 최종 배포된 프로젝트에 심각한 버그가 발견했을 때 master 브랜치에서 hotfix 브랜치를 만들어 버그 수정 작업을 합니다.
11. 버그 수정 작업 완료 후에는 master 브랜치와 develop 브랜치에 머지합니다.
12. 버그 수정이 완료된 master 브랜치의 프로젝트의 최종 커밋에 다시 tag를 달아 프로젝트 버전을 명시합니다.

> ***프로젝트 라이프사이클**
>
> 계속해서 운영하는 프로젝트가 위 사이클을 거치고 끝나지 않습니다. 이후에도 계속해서 추가 개발과 버그 수정 등의 작업을 하죠. 위에서 소개한 Gitflow 역시 그렇습니다. 보통 프로젝트 라이프사이클을 다시 간략히 정리해보면 다음처럼 이루어집니다.
>
> 1. 이번 버전에서 어떤 기능을 추가하거나, 기존 버그를 수정할지 정합니다.
> 2. 위에서 정한 내용들을 작업합니다.
> 3. 최종 배포 전까지 계속해서 테스트와 피드백을 거쳐 수정합니다.
> 4. 이후 배포하고, 버전을 달아줍니다.
> 5. 이제 다음 버전에 대해 1~4의 과정을 반복합니다.
>
> 따라서 버전은 계속해서 위같은 라이프사이클을 거쳐 바뀌게 됩니다. 버전 역시 어떻게 매길 것인가에 대해 고민하게 되는데, 이러한 버저닝 전략 역시 대표적인 몇가지 패턴이 존재합니다. 자세한 내용은 아래 더 공부하면 좋은 것들에서 확인해보세요.



### 장단점

Gitflow 패턴을 사용하면 다음과 같은 장점이 있습니다.

- 브랜치의 이름과 개수를 통일성있게 가져갈 수 있습니다.
    - master, develop 브랜치는 항상 존재합니다.
- 브랜치간 작업 흐름이 명확합니다.
    - feature -> develop -> release -> master 로 흐릅니다.
- 브랜치를 명확하게 나눴기 때문에 브랜치별로 담당 팀을 명확하게 나눌 수 있습니다.
    - 예를 들어 `feature/user` 는 유저 관련 팀이, `feature/payment` 는 결제 관련 팀이 담당할 수 있습니다.
    - QA팀에게 `release` 브랜치에 있는 프로젝트만 제공할 수 있습니다.

한편 다음과 같은 단점도 있습니다.

- 5개의 브랜치나 알아야하는 게 부담스러울 수 있습니다.
- 별도의 QA팀이 없고, 개발 팀이 직접 통합 테스트해야 하는 경우, 굳이 release 브랜치가 필요 없을 수도 있습니다.
    - develop 브랜치에 있는 내용으로 테스트하고 수정하는게 더 빠를 수 있습니다.
- 프로젝트가 항상 위와같은 명확한 라이프사이클을 가지는 것은 아닙니다.
    - 이번 버전에는 무엇을 만들자! 가 아니라, 필요에 따라 매번 기능을 즉각적으로 테스트하고 배포한 뒤, 버저닝을 후에 매길 수도 있습니다.
    - 이 때문에 Gitflow는 주로 소프트웨어 공학론에서 말하는 애자일(agile)한 모델보다는, 폭포수(waterfall) 모델에 어울린다는 평도 있습니다.
    - 규모가 작은 조직은 개발자가 적고, 보통 QA팀이 없기 때문에 굳이 Gitflow 방식을 쓸 이유가 없을 수 있습니다.

> 실제로는 각 팀에 맞게 Gitflow 전략을 수정하여 사용합니다. 예를 들어, 각 브랜치 이름을 다르게 둔다거나,  release 브랜치를 사용하지 않는다거나 하는 식으로요! 보통 master, develop, feature 브랜치 개념에 해당하는 식으로 브랜치를 활용하고 있으면 gitflow 전략이라고 부르기도 합니다.

<br>

## 더 알아두면 좋을 내용

- [배달의 민족 블로그 - 우린 Git-flow를 사용하고 있어요](https://techblog.woowahan.com/2553/)
    - 배민에서 gitflow 전략을 어떻게 사용하는지 소개합니다.
- [ujuc님 블로그 - Git flow, GitHub flow, GitLab flow](https://ujuc.github.io/2015/12/16/git-flow-github-flow-gitlab-flow/)
    - Gitflow 전략 외에 다른 대표적인 두 전략에 대해 소개합니다.
- [kentrick님 블로그 - 다양한 소프트웨어 버전 명명 (Software versioning)](https://blog.sonim1.com/243)
    - 소프트웨어 프로젝트에서 대표적인 버저닝 패턴들을 소개합니다.
