# 객체지향의 기본적인 개념들 짚고 가기

이번 글에서는 이해하기 쉬운 파이썬 코드를 통해 객체지향의 기본적인 개념들을 알아보겠습니다.

<br>

## 클래스와 인스턴스

### 클래스

객체지향을 지원하는 대부분의 프로그래밍 언어에서는 객체 구현을 위해 `클래스(class)`를 지원합니다.  
예를 들어 파이썬에는 다음처럼 `class`로 객체를 표현할 수 있습니다.

```python
# 아무 내용이 없는 비어있는 클래스
class User:
    pass  
```

### 인스턴스

그리고 이 클래스를 다음처럼 하나의 인스턴스로 만들 수 있습니다. 이를 클래스를 인스턴스화 한다고 합니다.

```python
>>> user_1 = User()
>>> user_2 = User()
```

`user_1` 과 `user_2` 는 같은 클래스로부터 만들어졌지만, 서로 다른 인스턴스입니다. 즉 이 둘은 같은 형태(클래스)를 취하고 있지만, 각자 다른 메모리 공간에 존재하고, 각자 독립된 내용을 담을 수 있습니다.

```python
>>> user_1 == user_2
False
```

<br>

## 속성(인스턴스 변수)과 메서드

### 속성

클래스의 `속성(attribute)`은 클래스 내에 담기는 데이터들을 말합니다.  
클래스 속성은 크게 클래스 변수와 인스턴스 변수로 나눠볼 수 있습니다.

#### 인스턴스 변수

`인스턴스 변수`는 인스턴스 별로 독립적으로 가질 수 있는 값입니다. 다음은 인스턴스 변수를 정의한 예시입니다.

```python
class User:
    def __init__(self, name: str, job: str) -> None:
        self.name = name
        self.job = job
```

이렇게 정의한 인스턴스 변수는 다음처럼 인스턴스 별로 다르게 설정할 수 있습니다.

```python
user_1 = User(name="grab", job="data_engineer")
user_2 = User(name="heumsi", job="project_manager")
```

인스턴스 변수는 다음과 같이 접근합니다.

```python
>>> user_1.name
grab
>>> user_1.job
data_engineer
```

#### 클래스 변수

`클래스 변수`는 클래스 자체에 정의되는 변수입니다. 같은 클래스의 인스턴스들은 같은 클래스 변수값을 가지게 됩니다.

```python
class User:
    num_users: int = 0
    
    def __init__(self, name: str, job: str) -> None:
        self.name = name
        self.job = job
        self.num_users += 1
```

클래스 변수 역시 인스턴스 변수와 같은 방식으로 접근합니다.

```python
# 클래스 변수는 인스턴스화 하지 않아도 접근이 가능합니다.
>>> User.num_users
0

# 인스턴스화한 후에도 접근이 가능합니다.
>>> user_1 = User(name="grab", job="data_engineer")
>>> user_1.num_users
1

# 서로 다른 인스턴스더라도 클래스 변수는 공유됩니다.
>>> user_2 = User(name="heumsi", job="project_manager")
>>> user_2.num_users
2
```

인스턴스 별로 독립된 메모리 공간을 가지는 인스턴스 변수와 달리, 클래스 변수는 같은 클래스의 인스턴스들이 공유합니다.



### 메서드

메서드는 클래스가 가지고 있는 함수이자 객체가 할 수 있는 행위를 말합니다.  
메서드는 크게 공개형(public) 메서드와 비공개형(private) 메서드로 나눠볼 수 있습니다.

#### 공개형 메서드

공개형 메서드는 이 클래스가 외부에 제공해주는 메서드입니다. 다음 예시에서 `work()` 는 공개형 메서드 입니다.

```python
class User:
    def __init__(self, name: str, job: str) -> None:
        self.name = name
        self.job = job
    
    def work(self) -> None:
        if self.job == "data_enginner":
            print("데이터 엔지니어링 관련된 일을 합니다.")
        elif self.job == "project_manager":
            print("프로젝트 매니징 관련된 일을 합니다.")
```

이렇게 정의된 공개형 메서드는 클래스 외부에서 다음처럼 사용할 수 있습니다.

```python
>>> user_1 = User(name="grab", job="data_engineer")
>>> user_1.work()

"데이터 엔지니어링 관련된 일을 합니다."
```

#### 비공개형 메서드

비공개형 메서드는 클래스 내부에서만 사용하는 메서드입니다. 다음 예시에서 `_get_work_type()` 메서드는 비공개형 메서드 입니다.

```python
class User:
    def __init__(self, name: str, job: str) -> None:
        self.name = name
        self.job = job
    
    def work(self) -> None:
        work_type = self._get_work_type()
        print(f"{work_type} 관련된 일을 합니다.")
            
    def _get_work_type(self) -> str:
        if self.job == "data_enginner":
            return "데이터 엔지니어링"
       	elif self.job == "project_manager":
            return "프로젝트 매니징"
```

비공개형 메서드는 외부에서 접근하지 못하거나, 할 수 있더라도 하지 않는게 관습입니다. 위의 예시처럼 비공개형 메서드는 공개형 메서드의 로직의 일부를 내부적으로 재사용하고, 의미를 분리하기 위해 사용하기 위한 목적으로 사용하곤 합니다.

:::tip
**접근 제어자**

접근 제어자는 변수 혹은 함수(메서드)에 대한 접근을 제어하는 역할을 합니다.

예를 들면 자바와 같은 객체지향적 언어에는 `private` , `protected`, `private` 과 같은 접근 제어자가 있습니다. `private` 으로 표시된 변수나 메서드는 클래스 내부에서만 접근할 수 있습니다. 클래스 외부에서 접근하려고 할 시, 컴파일 시점에 에러를 뱉습니다. 객체지향 언어에서는 보통 이런 제어자를 통해 공개형, 비공개형에 대한 표시를 아주 명확히하곤 합니다.
:::

:::tip
파이썬의 경우 자바와 다르게 접근 제어자 문법이 없습니다. 다만 변수나 메서드 이름 앞에 `_` (underscore) 를 붙임으로써 비공개 변수, 메서드임을 명시하는게 관습입니다.
:::

<br>

## 상속

객체지향 프로그래밍 언어들은 대부분 클래스 문법과 상속을 제공합니다. `상속(inheritance)`은 이전에 정의한 클래스의 데이터와 메서드를 그대로 내려받는 기능입니다. 이때 상속해주는 클래스를 "부모 클래스" 혹은 "기반 클래스"라고 하며, 상속받는 클래스를 "자식 클래스" 혹은 "파생 클래스"라고 합니다.

다음은 파이썬에서 상속의 예시입니다.

```python
class Job:
    def do(self) -> None:
        print(f"{self.work_type} 관련된 일을 합니다.")
    
    
class DataEnginner(Job):
    work_type = "데이터 엔지니어링"
    
    
class ProjectManager(Job):
    work_type = "프로젝트 매니징"
```

`DataEnginner`, `ProjectManager` 클래스가 `Job` 클래스를 상속받았습니다. `Job`클래스체는 부모 클래스, `DataEnginner`, `ProjectManager` 클래스는 자식 클래스가 됩니다.

`DataEnginner`, `ProjectManager` 클래스는 `Job` 을 상속받았으므로, `Job` 클래스에서 정의한 `do(self)` 메서드를 그대로 사용할 수 있습니다.

```python
>>> data_enginner = DataEnginner()
>>> data_enginner.do()

"데이터 엔지니어링 관련된 일을 합니다."
```

<br>

## 인터페이스
### 인터페이스

`인터페이스(interface)`는 객체의 행위(메서드)만을 정의한 것으로, 구체적으로는 클래스의 메서드의 명세라고 볼 수 있습니다

파이썬에서는 인터페이스가 따로 없어 추상클래스로 인터페이스를 구현하였습니다.

```python
from abc import ABC, abstractmethod

class Job(ABC):
    @abstractmethod
    def do(self) -> None:
        pass
```

### 구현체

인터페이스는 보통 그대로 인스턴스화 할 수 없습니다. 예를 들어 다음 코드는 에러를 뱉습니다.

```python
>>> job = Job()

Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: Can't instantiate abstract class Job with abstract methods do
```

인터페이스는 객체의 뼈대만을 담당하고 있습니다. 실제로는 다음처럼 인터페이스 객체를 상속받는 구현 클래스도 구현해야 합니다.

```python
class DataEngineer(Job):
    def do(self) -> None:
        print("데이터 엔지니어링 관련된 일을 합니다.")

class ProjectManager(Job):
    def do(self) -> None:
        print("프로젝트 매니징 관련된 일을 합니다.")
```

```python
>>> data_engineer = DataEngineer()
>>> data_enginner.do()

"데이터 엔지니어링 관련된 일을 합니다."
```

### 인터페이스 사용 이유

인터페이스는 왜 사용하는 걸까요?

우리가 은행에 가서 은행원에게 돈을 입금해달라고 합시다. 우리는 은행원이 우리에게 돈을 입금해주는 행위을 제공하고 있습니다. 하지만 구체적으로 이 은행원이 어떻게 돈을 입금해주는지에 대해서는 관심이 없습니다. 그걸 몰라도 우리는 입금해달라고 요청하면 입금이 잘 될거라는 것을 알고있고 신뢰하기 때문입니다.

마찬가지로 위에서 정의한 `Job`을 외부에서 사용하는 코드(보통 클라이언트라고 합니다)는 `Job` 이 어떤 행위를 제공하는 지(`Job` 의 퍼블릭 메서드)에 주로 관심이 있습니다. `Job`이  어떤 데이터를 들고있으며, 행위을 하기 위해 구체적으로 어떤 알고리즘을 가지고 있는지는, 클라이언트 입장에서는 중요하지 않습니다. 우리는 Job이 어떤 행위를 제공하는지 보려면 그저 `Job` 이라고 하는 인터페이스만 보면 됩니다.   

또한 `DataEngineer(Job)` , `ProjectManager(Job)` 와 같은 구현 클래스가 `Job` 추상 클래스를 상속받는 것을 통해 이 두 클래스가 같은 개념 아래 묶여있는 것을 알 수 있습니다. 즉 구현 클래스 간의 관계를 파악하기 쉽습니다.

<br>

## 의존성

객체 A 입장에서 객체 B의 존재를 알고 있을 때, "객체 A는 객체 B에 의존성이 있다" 라고 합니다.  
의존성은 크게 2가지로 나눠볼 수 있습니다.

### 정적 의존성

코드 레벨에서 객체 A 내에서 객체 B에 접근하는 경우 입니다. 다음 예시를 보겠습니다.

```python
from abc import ABC, abstractmethod

class Job(ABC):
    @abstractmethod
    def do(self) -> None:
        pass

    
class DataEngineer(Job):
     def do(self) -> None:
        print(f"데이터 엔지니어링 관련된 일을 합니다.")
        

class User:
    def __init__(self, name: str, job: DataEngineer) -> None:
        self.name = name
        self.job = job
        
    def work(self) -> None:
        self.job.do()
```

위 코드에서 `User` 의 생성자(`__init__(self)` 메서드) 에서  `DataEngineer` 객체를 파라미터로 받고 있습니다. 즉 `User` 가 `DataEngineer` 이라고 하는 객체의 존재를 알고 있는 것입니다. 이처럼 코드 레벨에서 직접적으로 두 객체의 의존 관계를 파악할 수 있을 때, 정적 의존성이 있다고 합니다. 컴파일 의존성이라고도 합니다.

위의 경우 `User` 객체가 `DataEngineer` 객체에 정적 의존성이 있습니다. 

### 동적 의존성

코드 레벨에서 의존성이 드러나지는 않지만, 실제 실행 과정에서 두 객체간 의존 관계가 있을 때 동적 의존성 관계에 있다고 합니다. 다음 예시를 보겠습니다.

```python
from abc import ABC

class Job(ABC):
    def do(self) -> None:
        print(f"{self.work_type} 관련된 일을 합니다.")
    
    
class DataEnginner(Job):
    work_type = "데이터 엔지니어링"
    
    
class ProjectManager(Job):
    work_type = "프로젝트 매니징"
    
    
class User:
    def __init__(self, name: str, job: Job) -> None:
        self.name = name
        self.job = job
        
    def work(self) -> None:
        self.job.do()
```

위 코드에서 `User` 객체는 `Job` 객체(인터페이스)에 정적인 의존성이 있습니다. `DataEnginner` , `ProjectManager` 에는 의존성이 없습니다.

하지만 다음처럼 실제 코드가 실행될 때 `User` 에 `DataEnginner` 나  `ProjectManager` 에 의존성이 있도록 만들어줄 수 있습니다.

```python
>>> user_1 = User(name="grab", job=DataEnginner())  # 여기서 동적으로 의존성을 만들어줍니다.
>>> user_1.work()

"데이터 엔지니어링 관련된 일을 합니다."
```

만약 `ProjectManager` 로 의존성을 주고 싶으면 다음처럼 하면 됩니다.

```python
>>> user_2 = User(name="grab", job=ProjectManager())  # 여기서 동적으로 의존성을 만들어줍니다.
>>> user_2.work()

"프로젝트 매니징 관련된 일을 합니다."
```

동적 의존성은 이렇게 코드 레벨이 아닌, 실제 실행 환경에서 동적으로 의존 관계를 형성할 수 있는 의존성을 말합니다. 보통 위와 같이 추상 클래스 혹은 인터페이스를 파라미터 타입으로 두고 (`def __init__(self, name: str, job: Job)` 부분 ) 실제로 위 클래스를 생성할 때 구체적인 클래스를 인자로 넘겨주는 방식(`User(name="grab", job=DataEnginner())`)으로 동적 의존성을 구현하곤 합니다.

## 결합도(Coupling)와 응집도(Cohension)

객체지향에서 좋은 설계란 무엇일까요? 흔히들 좋은 설계란 "낮은 결합도와 높은 응집도를 가진 설계"라고 말하곤 합니다. 그렇다면 결합도와 응집도란 무엇일까요?

`결합도`란 객체간 의존하는 정도(정적 의존성)를 말합니다. 기본적으로 한 객체가 여러 객체를 아는 것(의존성이 높은 것)은 좋지 않습니다. 객체를 생성하거나 내부의 로직을 이해하는데 알아야할 것이 많아지고, 의존하는 객체가 수정되면 이 객체 역시 영향을 받기 때문이죠. 하지만 객체지향은 여러 객체간의 협력을 통해 로직의 흐름을 아예 의존성이 없는 것은 불가능합니다. 결국 결합도를 낮게 유지할 수 있는 방향으로 코드를 작성하는 게 중요합니다.  

적절하게 의존성을 가지려면, 애초에 객체들이 SRP에 맞게 잘 설계되어야 합니다. 그래야 중구난방으로 객체가 존재하지도 않고, 반대로 한 객체가 너무 큰 책임을 가지지도 않게 되죠. 이처럼 객체가 필요한 책임에 맞게 적절하게 속성과 데이터들이 모여있는 정도를 `응집도`라고 합니다. 

**정리하면 개별 객체에는 책임에 따른 기능들이 충분히 모여있고(높은 응집도), 이런 객체들이 서로 협력하는 과정에서 의존하는 정도를 최소한으로 만드는 것(낮은 결합도)이 바로 객체지향에서 말하는 좋은 설계입니다.**

